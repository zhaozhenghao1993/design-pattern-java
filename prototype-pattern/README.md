# 原型模式

[对象的克隆——原型模式（一）：大同小异的工作周报，原型模式概述](https://blog.csdn.net/lovelion/article/details/7424559)

[对象的克隆——原型模式（二）：工作周报的原型模式解决方案](https://blog.csdn.net/lovelion/article/details/7424594)

[对象的克隆——原型模式（三）：带附件的周报【浅克隆，深克隆】](https://blog.csdn.net/lovelion/article/details/7424620)

[对象的克隆——原型模式（四）：原型管理器的引入和实现，原型模式总结](https://blog.csdn.net/lovelion/article/details/7424623)

```aidl
    原型模式(Prototype  Pattern)：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
原型模式是一种对象创建型模式。
    原型模式的工作原理很简单：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。
由于在软件系统中我们经常会遇到需要创建多个相同或者相似对象的情况，因此原型模式在真实开发中的使用频率还是非常高的。
原型模式是一种“另类”的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法来实现。
    
    需要注意的是通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址,
通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。
通过不同的方式修改可以得到一系列相似但不完全相同的对象。

    
 在原型模式结构图中包含如下几个角色：

      ●Prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。

      ● ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。

      ● Client（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，
再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，
因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。

```